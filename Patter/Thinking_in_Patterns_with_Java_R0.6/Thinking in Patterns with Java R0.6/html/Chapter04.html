<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<HTML>
<!--
This document was converted from RTF source: 
By rtftohtml 4.19
See http://www.sunpack.com/RTF
Filename:TIPatterns.rtf
Application Directory:c:\tools\rtf2html\
Subject:
Author:Bruce Eckel
Operator:Bruce Eckel
Document Comments:
Version Comments:
Comments:
Keywords:
Translation Date:09/08/2001
Translation Time:10:16:40
Translation Platform:Win32
Number of Output files:18
This File:Chapter04.html
SplitDepth=1
SkipNavPanel=1
SkipLeadingToc=1
SkipTrailingToc=1
GenContents=1
GenFrames=1
GenIndex=1
-->
<HEAD lang="en"><META http-equiv="Content-Type" content="text/html">
<TITLE>4:Fronting for an implementation</TITLE>
</HEAD>

<BODY  BGCOLOR="#FFFFFF"><DIV ALIGN="CENTER">
  <a href="http://www.MindView.net">
  <img src="mindview-head.gif" alt="MindView Inc." BORDER = "0"></a>
  <CENTER>
    <FONT FACE="Verdana" size = "-1">
    [ <a href="README-HTML.txt">Viewing Hints</a> ]
    [ <a href="RevisionHistory.html">Revision History</a> ]
    [ <a href="Building-Code.html">Build the Code</a> ]
    [ <a href="TIPatterns-Corrections.html">Report an Error</a> ] <br>
    [ <a href="http://www.mindview.net/MailingList.html">Free Newsletter</a> ]
    [ <a href="http://www.mindview.net/Training.html">Seminars</a> ]
    [ <a href="http://www.mindview.net/CPPServices/#ConsultingServices">Consulting</a> ]
    </FONT>
  <H2><FONT FACE="Verdana">
  Thinking in Patterns <font size="4">with Java</font>, Revision 0.6</FONT></H2>
  <H3><FONT FACE="Verdana">&copy;2001 by Bruce Eckel</FONT></H3>
  
    <FONT FACE="Verdana" size = "-1">
     [ <a href="Chapter03.html">Previous Chapter</a> ] 
    [ <a href="SimpleContents.html">Short TOC</a> ] 
    [ <a href="Contents.html">Table of Contents</a> ] 
    [ <a href="DocIndex.html">Index</a> ]
     [ <a href="Chapter0X.html">Next Chapter</a> ] 
    </FONT>
    
  </CENTER>
  </P></DIV><A NAME="_Toc476705898"></A><A NAME="_Toc524504100"></A><A NAME="Heading26"></A><FONT FACE = "Verdana"><H1 ALIGN="LEFT">
4:Fronting for an implementation</H1></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Both <I>Proxy</I> and <I>State</I>
provide a surrogate class that you use in your code; the real class that does
the work is hidden behind this surrogate class. When you call a method in the
surrogate, it simply turns around and calls the method in the implementing
class. These two patterns are so similar that the <I>Proxy</I> is simply a
special case of <I>State</I>. One is tempted to just lump the two together into
a pattern called <I>Surrogate</I>, but the term &#8220;proxy&#8221; has a
long-standing and specialized meaning, which probably explains the reason for
the two different patterns.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The basic idea is simple: from a base
class, the surrogate is derived along with the class or classes that provide the
actual implementation: </FONT><BR></P></DIV>
<DIV ALIGN="CENTER"><FONT FACE="Georgia"><IMG SRC="TIPatt00.gif"></FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">When a surrogate object is created, it is
given an implementation to which to send all of the method
calls.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Structurally, the difference between
<I>Proxy</I> and <I>State</I> is simple: a <I>Proxy</I> has only one
implementation, while <I>State</I> has more than one. The application of the
patterns is considered (in <I>Design Patterns</I>) to be distinct: <I>Proxy</I>
is used to control access to its implementation, while <I>State</I> allows you
to change the implementation dynamically. However, if you expand your notion of
&#8220;controlling access to implementation&#8221; then the two fit neatly
together.</FONT><A NAME="_Toc476705899"></A><A NAME="_Toc524504101"></A><BR></P></DIV>
<A NAME="Heading27"></A><FONT FACE = "Verdana"><H2 ALIGN="LEFT">
Proxy</H2></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">If we implement <I>Proxy</I> by following
the above diagram, it looks like this:</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: c04:ProxyDemo.java</font>
<font color=#009900>// Simple demonstration of the Proxy pattern.</font>
<font color=#0000ff>import</font> com.bruceeckel.test.*;

<font color=#0000ff>interface</font> ProxyBase {
  <font color=#0000ff>void</font> f();
  <font color=#0000ff>void</font> g();
  <font color=#0000ff>void</font> h();
}

<font color=#0000ff>class</font> Proxy <font color=#0000ff>implements</font> ProxyBase {
  <font color=#0000ff>private</font> ProxyBase implementation;
  <font color=#0000ff>public</font> Proxy() { 
    implementation = <font color=#0000ff>new</font> Implementation(); 
  }
  <font color=#009900>// Pass method calls to the implementation:</font>
  <font color=#0000ff>public</font> <font color=#0000ff>void</font> f() { implementation.f(); }
  <font color=#0000ff>public</font> <font color=#0000ff>void</font> g() { implementation.g(); }
  <font color=#0000ff>public</font> <font color=#0000ff>void</font> h() { implementation.h(); }
}

<font color=#0000ff>class</font> Implementation <font color=#0000ff>implements</font> ProxyBase {
  <font color=#0000ff>public</font> <font color=#0000ff>void</font> f() { 
    System.out.println(<font color=#004488>"Implementation.f()"</font>); 
  }
  <font color=#0000ff>public</font> <font color=#0000ff>void</font> g() { 
    System.out.println(<font color=#004488>"Implementation.g()"</font>); 
  }
  <font color=#0000ff>public</font> <font color=#0000ff>void</font> h() { 
    System.out.println(<font color=#004488>"Implementation.h()"</font>); 
  }
}

<font color=#0000ff>public</font> <font color=#0000ff>class</font> ProxyDemo <font color=#0000ff>extends</font> UnitTest {
  Proxy p = <font color=#0000ff>new</font> Proxy();
  <font color=#0000ff>public</font> <font color=#0000ff>void</font> test() {
    <font color=#009900>// This just makes sure it will complete </font>
    <font color=#009900>// without throwing an exception.</font>
    p.f();
    p.g();
    p.h();
  }
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> main(String args[]) {
    <font color=#0000ff>new</font> ProxyDemo().test();
  }
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE><DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Of course, it isn&#8217;t
necessary that <B>Implementation</B> have the same interface as <B>Proxy</B>; as
long as <B>Proxy</B> is somehow &#8220;speaking for&#8221; the class that it is
referring method calls to then the basic idea is satisfied (note that this
statement is at odds with the definition for Proxy in GoF). However, it is
convenient to have a common interface so that <B>Implementation</B> is forced to
fulfill all the methods that <B>Proxy</B> needs to
call.</FONT><A NAME="_Toc476705900"></A><A NAME="_Toc524504102"></A><BR></P></DIV>
<A NAME="Heading28"></A><FONT FACE = "Verdana"><H2 ALIGN="LEFT">
State</H2></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The <I>State</I> pattern adds more
implementations to <I>Proxy</I>, along with a way to switch from one
implementation to another during the lifetime of the surrogate:</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: c04:StateDemo.java</font>
<font color=#009900>// Simple demonstration of the State pattern.</font>
<font color=#0000ff>import</font> com.bruceeckel.test.*;

<font color=#0000ff>interface</font> StateBase {
  <font color=#0000ff>void</font> f();
  <font color=#0000ff>void</font> g();
  <font color=#0000ff>void</font> h();
}

<font color=#0000ff>class</font> State_d <font color=#0000ff>implements</font> StateBase {
  <font color=#0000ff>private</font> StateBase implementation;
  <font color=#0000ff>public</font> State_d(StateBase imp) { 
    implementation = imp; 
  }
  <font color=#0000ff>public</font> <font color=#0000ff>void</font> changeImp(StateBase newImp) {
    implementation = newImp;
  }
  <font color=#009900>// Pass method calls to the implementation:</font>
  <font color=#0000ff>public</font> <font color=#0000ff>void</font> f() { implementation.f(); }
  <font color=#0000ff>public</font> <font color=#0000ff>void</font> g() { implementation.g(); }
  <font color=#0000ff>public</font> <font color=#0000ff>void</font> h() { implementation.h(); }
}

<font color=#0000ff>class</font> Implementation1 <font color=#0000ff>implements</font> StateBase {
  <font color=#0000ff>public</font> <font color=#0000ff>void</font> f() { 
    System.out.println(<font color=#004488>"Implementation1.f()"</font>); 
  }
  <font color=#0000ff>public</font> <font color=#0000ff>void</font> g() { 
    System.out.println(<font color=#004488>"Implementation1.g()"</font>); 
  }
  <font color=#0000ff>public</font> <font color=#0000ff>void</font> h() { 
    System.out.println(<font color=#004488>"Implementation1.h()"</font>); 
  }
}

<font color=#0000ff>class</font> Implementation2 <font color=#0000ff>implements</font> StateBase {
  <font color=#0000ff>public</font> <font color=#0000ff>void</font> f() { 
    System.out.println(<font color=#004488>"Implementation2.f()"</font>); 
  }
  <font color=#0000ff>public</font> <font color=#0000ff>void</font> g() { 
    System.out.println(<font color=#004488>"Implementation2.g()"</font>); 
  }
  <font color=#0000ff>public</font> <font color=#0000ff>void</font> h() { 
    System.out.println(<font color=#004488>"Implementation2.h()"</font>); 
  }
}

<font color=#0000ff>public</font> <font color=#0000ff>class</font> StateDemo <font color=#0000ff>extends</font> UnitTest {
  <font color=#0000ff>static</font> <font color=#0000ff>void</font> run(State_d b) {
    b.f();
    b.g();
    b.h();
  }
  State_d b = <font color=#0000ff>new</font> State_d(<font color=#0000ff>new</font> Implementation1());
  <font color=#0000ff>public</font> <font color=#0000ff>void</font> test() {
    <font color=#009900>// This just makes sure it will complete </font>
    <font color=#009900>// without throwing an exception.</font>
    run(b);
    b.changeImp(<font color=#0000ff>new</font> Implementation2());
    run(b);
  }
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> main(String args[]) {
    <font color=#0000ff>new</font> StateDemo().test();
  }
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE><DIV ALIGN="LEFT"><P><FONT FACE="Georgia">In <B>main(&#160;)</B>, you
can see that the first implementation is used for a bit, then the second
implementation is swapped in and that is used.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The difference between <I>Proxy</I> and
<I>State</I> is in the problems that are solved. The common uses for
<I>Proxy</I> as described in <I>Design Patterns</I> are:</FONT><BR></P></DIV>
<OL>
<LI><FONT FACE="Verdana"><B>	</B></FONT><FONT FACE="Georgia"><B>Remote
proxy</B>. This proxies for an object in a different address space. A remote
proxy is created for you automatically by the RMI compiler <B>rmic</B> as it
creates stubs and
skeletons.</FONT><LI><FONT FACE="Verdana"><B>	</B></FONT><FONT FACE="Georgia"><B>Virtual
proxy</B>. This provides &#8220;lazy initialization&#8221; to create expensive
objects on
demand.</FONT><LI><FONT FACE="Verdana"><B>	</B></FONT><FONT FACE="Georgia"><B>Protection
proxy</B>. Used when you don&#8217;t want the client programmer to have full
access to the proxied
object.</FONT><LI><FONT FACE="Verdana"><B>	</B></FONT><FONT FACE="Georgia"><B>Smart
reference</B>. To add additional actions when the proxied object is accessed.
For example, or to keep track of the number of references that are held for a
particular object, in order to implement the <I>copy-on-write</I> idiom and
prevent object aliasing. A simpler example is keeping track of the number of
calls to a particular
method.</FONT></OL><DIV ALIGN="LEFT"><P><FONT FACE="Georgia">You could look at a
Java reference as a kind of protection proxy, since it controls access to the
actual object on the heap (and ensures, for example, that you don&#8217;t use a
<B>null </B>reference).</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">[[ Rewrite this: In <I>Design
Patterns</I>, <I>Proxy</I> and <I>State</I> are not seen as related to each
other because the two are given (what I consider arbitrarily) different
structures. <I>State</I>, in particular, uses a separate implementation
hierarchy but this seems to me to be unnecessary unless you have decided that
the implementation is not under your control (certainly a possibility, but if
you own all the code there seems to be no reason not to benefit from the
elegance and helpfulness of the single base class). In addition, <I>Proxy</I>
need not use the same base class for its implementation, as long as the proxy
object is controlling access to the object it &#8220;fronting&#8221; for.
Regardless of the specifics, in both <I>Proxy </I>and <I>State</I> a surrogate
is passing method calls through to an implementation
object.]]]</FONT><A NAME="_Toc476705901"></A><A NAME="_Toc524504103"></A><BR></P></DIV>
<A NAME="Heading29"></A><FONT FACE = "Verdana"><H2 ALIGN="LEFT">
StateMachine</H2></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">While <I>State</I> has a way to allow the
client programmer to change the implementation, <I>StateMachine</I> imposes a
structure to automatically change the implementation from one object to the
next. The current implementation represents the state that a system is in, and
the system behaves differently from one state to the next (because it uses
<I>State</I>). Basically, this is a &#8220;state machine&#8221; using
objects.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The code that moves the system from one
state to the next is often a <I>Template Method</I>, as seen in the following
framework for a basic state machine. We start by defining a tagging interface
for input objects:</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: c04:statemachine:Input.java</font>
<font color=#009900>// Inputs to a state machine</font>
<font color=#0000ff>package</font> c04.statemachine;

<font color=#0000ff>public</font> <font color=#0000ff>interface</font> Input {} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE><DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Each
state can be <B>run(&#160;)</B> to perform its behavior, and (in this design)
you can also pass it an <B>Input</B> object so it can tell you what new state to
move to based on that <B>Input</B>. The key distinction between this design and
the next is that here, each <B>State</B> object decides what other states it can
move to, based on the <B>Input</B>, whereas in the subsequent design all of the
state transitions are held in a single table. Another way to put it is that
here, each <B>State</B> object has its own little <B>State</B> table, and in the
subsequent design there is a single master state transition table for the whole
system.</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: c04:statemachine:State.java</font>
<font color=#009900>// A State has an operation, and can be moved</font>
<font color=#009900>// into the next State given an Input:</font>
<font color=#0000ff>package</font> c04.statemachine;

<font color=#0000ff>public</font> <font color=#0000ff>interface</font> State {
  <font color=#0000ff>void</font> run();
  State next(Input i);
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE><DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The <B>StateMachine</B>
keeps track of the current state, which is initialized by the constructor. The
<B>runAll(&#160;)</B> method takes an <B>Iterator</B> to a list of <B>Input</B>
objects (an <B>Iterator</B> is used here for convenience and simplicity; the
important issue is that the input information comes from somewhere). This method
not only moves to the next state, but it also calls <B>run(&#160;)</B> for each
state object &#8211; thus you can see it&#8217;s an expansion of the idea of the
<B>State</B> pattern, since <B>run(&#160;)</B> does something different
depending on the state that the system is in.</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: c04:statemachine:StateMachine.java</font>
<font color=#009900>// This state machine takes an Iterator of Inputs</font>
<font color=#009900>// to move from State to State using a template</font>
<font color=#009900>// method.</font>
<font color=#0000ff>package</font> c04.statemachine;
<font color=#0000ff>import</font> java.util.*;

<font color=#0000ff>public</font> <font color=#0000ff>abstract</font> <font color=#0000ff>class</font> StateMachine {
  <font color=#0000ff>private</font> State currentState;
  <font color=#0000ff>public</font> StateMachine(State initialState) {
    currentState = initialState;
    currentState.run();
  }
  <font color=#009900>// Template method:</font>
  <font color=#0000ff>public</font> <font color=#0000ff>final</font> <font color=#0000ff>void</font> 
  runAll(Iterator inputs) {
    <font color=#0000ff>while</font>(inputs.hasNext()) {
      Input i = (Input)inputs.next();
      System.out.println(i);
      currentState = currentState.next(i);
      currentState.run();
    }
  }
}  <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE><DIV ALIGN="LEFT"><P><FONT FACE="Georgia">I&#8217;ve also treated
<B>runAll(&#160;)</B> as a template method. This is typical, but certainly not
required &#8211; you could concievably want to override it, but typically the
behavior change will occur in <B>State</B>&#8217;s <B>run(&#160;)</B>
instead.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">At this point the basic framework for
this style of <I>StateMachine</I> (where each state decides the next states) is
complete. As an example, I&#8217;ll use a fancy mousetrap that can move through
several states in the process of trapping a
mouse</FONT><A NAME="fnB9" HREF="#fn9">[9]</A><FONT FACE="Georgia">. The mouse
classes and information are stored in the <B>mouse</B> package, including a
class representing all the possible moves that a mouse can make, which will be
the inputs to the state machine:</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: c04:mouse:MouseAction.java</font>
<font color=#009900>// This state machine takes an Iterator of Inputs</font>
<font color=#009900>// to move from State to State using a template</font>
<font color=#009900>// method.</font>
<font color=#0000ff>package</font> c04.mouse;
<font color=#0000ff>import</font> c04.statemachine.*;

<font color=#0000ff>public</font> <font color=#0000ff>class</font> MouseAction <font color=#0000ff>implements</font> Input {
  <font color=#0000ff>private</font> String action;
  <font color=#0000ff>public</font> MouseAction(String a) { action = a; }
  <font color=#0000ff>public</font> String toString() { <font color=#0000ff>return</font> action; }
  <font color=#0000ff>public</font> <font color=#0000ff>int</font> hashCode() { 
    <font color=#0000ff>return</font> action.hashCode();
  }
  <font color=#0000ff>public</font> <font color=#0000ff>boolean</font> equals(Object o) {
    <font color=#0000ff>return</font> (o <font color=#0000ff>instanceof</font> MouseAction)
      &amp;&amp; action.equals(((MouseAction)o).action);
  }
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> MouseAction
    appears = <font color=#0000ff>new</font> MouseAction(<font color=#004488>"mouse appears"</font>),
    runsAway = <font color=#0000ff>new</font> MouseAction(<font color=#004488>"mouse runs away"</font>),
    enters = <font color=#0000ff>new</font> MouseAction(<font color=#004488>"mouse enters trap"</font>),
    escapes = <font color=#0000ff>new</font> MouseAction(<font color=#004488>"mouse escapes"</font>),
    trapped = <font color=#0000ff>new</font> MouseAction(<font color=#004488>"mouse trapped"</font>),
    removed = <font color=#0000ff>new</font> MouseAction(<font color=#004488>"mouse removed"</font>);
} <font color=#009900>///:~</font>
</PRE></FONT></BLOCKQUOTE><DIV ALIGN="LEFT"><P><FONT FACE="Georgia">You&#8217;ll note that
<B>hashCode(&#160;)</B> and <B>equals(&#160;)</B> have been overriden so that
<B>MouseAction</B> objects can be used as keys in a <B>HashMap</B>, but in the
first version of the mousetrap we won&#8217;t do this. Also, each possible move
by a mouse is enumerated as a <B>static MouseAction</B> object.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">For creating test code, a sequence of
mouse inputs is provided from a text file:</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE>//:! c04:mouse:MouseMoves.txt
mouse appears
mouse runs away
mouse appears
mouse enters trap
mouse escapes
mouse appears
mouse enters trap
mouse trapped
mouse removed
mouse appears
mouse runs away
mouse appears
mouse enters trap
mouse trapped
mouse removed
///:~</PRE></FONT></BLOCKQUOTE><DIV ALIGN="LEFT"><P><FONT FACE="Georgia">To read this file in a generic
fashion, here is a general-purpose tool called
<B>StringList</B>:</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: com:bruceeckel:util:StringList.java</font>
<font color=#009900>// General-purpose tool that reads a file of text</font>
<font color=#009900>// lines into a List, one line per list.</font>
<font color=#0000ff>package</font> com.bruceeckel.util;
<font color=#0000ff>import</font> java.io.*;
<font color=#0000ff>import</font> java.util.*;

<font color=#0000ff>public</font> <font color=#0000ff>class</font> StringList <font color=#0000ff>extends</font> ArrayList {
  <font color=#0000ff>public</font> StringList(String textFile) {
    <font color=#0000ff>try</font> {
      BufferedReader inputs = 
        <font color=#0000ff>new</font> BufferedReader (
          <font color=#0000ff>new</font> FileReader(textFile));
      String line;
      <font color=#0000ff>while</font>((line = inputs.readLine()) != <font color=#0000ff>null</font>)
        add(line.trim());
    } <font color=#0000ff>catch</font> (IOException e) {
      e.printStackTrace(System.err);
    }
  }
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE><DIV ALIGN="LEFT"><P><FONT FACE="Georgia">This <B>StringList</B> only
holds <B>Object</B>s, just as an <B>ArrayList</B> does, so we need an adapter to
turn the <B>String</B>s into <B>MouseAction</B>s:</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: c04:mouse:MouseMoveList.java</font>
<font color=#009900>// A transformer to produce a</font>
<font color=#009900>// List of MouseAction objects.</font>
<font color=#0000ff>package</font> c04.mouse;
<font color=#0000ff>import</font> java.util.*;
<font color=#0000ff>import</font> com.bruceeckel.util.*;

<font color=#0000ff>public</font> <font color=#0000ff>class</font> MouseMoveList <font color=#0000ff>extends</font> ArrayList {
  <font color=#0000ff>public</font> MouseMoveList(Iterator sit) {
    <font color=#0000ff>while</font>(sit.hasNext())
      add(<font color=#0000ff>new</font> MouseAction((String)sit.next()));
  }
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE><DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The <B>MouseMoveList</B>
looks a bit like a decorator, and acts a bit like an adapter. However, an
adapter changes one interface to another, and a decorator adds functionality or
data. <B>MouseMoveList</B> changes the contents of the container, so it might be
thought of as a <I>Transformer</I>.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">With these tools in place, it&#8217;s now
possible to create the first version of the mousetrap program. Each <B>State</B>
subclass defines it&#8217;s <B>run(&#160;)</B> behavior, and also establishes
its next state with an <B>if-else</B> clause:</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: c04:mousetrap1:MouseTrapTest.java</font>
<font color=#009900>// State Machine pattern using 'if' statements</font>
<font color=#009900>// to determine the next state.</font>
<font color=#0000ff>package</font> c04.mousetrap1;
<font color=#0000ff>import</font> c04.mouse.*;
<font color=#0000ff>import</font> c04.statemachine.*;
<font color=#0000ff>import</font> com.bruceeckel.util.*;
<font color=#0000ff>import</font> java.util.*;
<font color=#0000ff>import</font> java.io.*;
<font color=#0000ff>import</font> com.bruceeckel.test.*;

<font color=#009900>// A different subclass for each state:</font>

<font color=#0000ff>class</font> Waiting <font color=#0000ff>implements</font> State {
  <font color=#0000ff>public</font> <font color=#0000ff>void</font> run() { 
    System.out.println(
      <font color=#004488>"Waiting: Broadcasting cheese smell"</font>);
  }
  <font color=#0000ff>public</font> State next(Input i) {
    MouseAction ma = (MouseAction)i;
    <font color=#0000ff>if</font>(ma.equals(MouseAction.appears))
      <font color=#0000ff>return</font> MouseTrap.luring;
    <font color=#0000ff>return</font> MouseTrap.waiting;
  }
}

<font color=#0000ff>class</font> Luring <font color=#0000ff>implements</font> State {
  <font color=#0000ff>public</font> <font color=#0000ff>void</font> run() {
    System.out.println(
      <font color=#004488>"Luring: Presenting Cheese, door open"</font>);
  }
  <font color=#0000ff>public</font> State next(Input i) {
    MouseAction ma = (MouseAction)i;
    <font color=#0000ff>if</font>(ma.equals(MouseAction.runsAway))
      <font color=#0000ff>return</font> MouseTrap.waiting;
    <font color=#0000ff>if</font>(ma.equals(MouseAction.enters))
      <font color=#0000ff>return</font> MouseTrap.trapping;
    <font color=#0000ff>return</font> MouseTrap.luring;
  }
}

<font color=#0000ff>class</font> Trapping <font color=#0000ff>implements</font> State {
  <font color=#0000ff>public</font> <font color=#0000ff>void</font> run() {
    System.out.println(<font color=#004488>"Trapping: Closing door"</font>);
  }
  <font color=#0000ff>public</font> State next(Input i) {
    MouseAction ma = (MouseAction)i;
    <font color=#0000ff>if</font>(ma.equals(MouseAction.escapes))
      <font color=#0000ff>return</font> MouseTrap.waiting;
    <font color=#0000ff>if</font>(ma.equals(MouseAction.trapped))
      <font color=#0000ff>return</font> MouseTrap.holding;
    <font color=#0000ff>return</font> MouseTrap.trapping;
  }
}

<font color=#0000ff>class</font> Holding <font color=#0000ff>implements</font> State {
  <font color=#0000ff>public</font> <font color=#0000ff>void</font> run() {
    System.out.println(<font color=#004488>"Holding: Mouse caught"</font>);
  }
  <font color=#0000ff>public</font> State next(Input i) {
    MouseAction ma = (MouseAction)i;
    <font color=#0000ff>if</font>(ma.equals(MouseAction.removed))
      <font color=#0000ff>return</font> MouseTrap.waiting;
    <font color=#0000ff>return</font> MouseTrap.holding;
  }
}

<font color=#0000ff>class</font> MouseTrap <font color=#0000ff>extends</font> StateMachine {
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> State 
    waiting = <font color=#0000ff>new</font> Waiting(),
    luring = <font color=#0000ff>new</font> Luring(),
    trapping = <font color=#0000ff>new</font> Trapping(),
    holding = <font color=#0000ff>new</font> Holding();
  <font color=#0000ff>public</font> MouseTrap() {
    <font color=#0000ff>super</font>(waiting); <font color=#009900>// Initial state</font>
  }
}

<font color=#0000ff>public</font> <font color=#0000ff>class</font> MouseTrapTest <font color=#0000ff>extends</font> UnitTest {
  MouseTrap trap = <font color=#0000ff>new</font> MouseTrap();
  MouseMoveList moves = 
    <font color=#0000ff>new</font> MouseMoveList(
      <font color=#0000ff>new</font> StringList(<font color=#004488>"..</font><font color=#004488>/mouse</font><font color=#004488>/MouseMoves.txt"</font>)
        .iterator());
  <font color=#0000ff>public</font> <font color=#0000ff>void</font> test() {
    trap.runAll(moves.iterator());
  }
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> main(String args[]) {
    <font color=#0000ff>new</font> MouseTrapTest().test();
  }
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE><DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The <B>StateMachine</B>
class simply defines all the possible states as static objects, and also sets up
the initial state. The <B>UnitTest</B> creates a <B>MouseTrap</B> and then tests
it with all the inputs from a <B>MouseMoveList</B>.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">While the</FONT><FONT FACE="Georgia"> use
of <B>if-else</B> statements inside the <B>next(&#160;)</B> methods is perfectly
reasonable, managing a large number of these could become difficult. Another
approach is to create tables inside each <B>State</B> object defining the
various next states based on the input.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Initially, this seems like it ought to be
quite simple. You should be able to define a <B>static</B> table in each
<B>State</B> subclass that defines the transitions in terms of the other
<B>State</B> objects. However, it turns out that this approach generates cyclic
initialization dependencies. To solve the problem, I&#8217;ve had to delay the
initialization of the tables until the first time that the <B>next(&#160;)</B>
method is called for a particular <B>State</B> object. Initially, the
<B>next(&#160;)</B> methods can appear a little strange because of
this.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The <B>StateT</B> class is an
implementation of <B>State</B> (so that the same <B>StateMachine</B> class can
be used from the previous example) that adds a <B>Map</B> and a method to
initialize the map from a two-dimensional array. The <B>next(&#160;)</B> method
has a base-class implementation which must be called from the overridden derived
class <B>next(&#160;)</B> methods after they test for a <B>null Map</B> (and
initialize it if it&#8217;s <B>null</B>):</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: c04:mousetrap2:MouseTrap2Test.java</font>
<font color=#009900>// A better mousetrap using tables</font>
<font color=#0000ff>package</font> c04.mousetrap2;
<font color=#0000ff>import</font> c04.mouse.*;
<font color=#0000ff>import</font> c04.statemachine.*;
<font color=#0000ff>import</font> java.util.*;
<font color=#0000ff>import</font> java.io.*;
<font color=#0000ff>import</font> com.bruceeckel.util.*;
<font color=#0000ff>import</font> com.bruceeckel.test.*;

<font color=#0000ff>abstract</font> <font color=#0000ff>class</font> StateT <font color=#0000ff>implements</font> State {
  <font color=#0000ff>protected</font> Map transitions = <font color=#0000ff>null</font>;
  <font color=#0000ff>protected</font> <font color=#0000ff>void</font> init(Object[][] states) {
    transitions = <font color=#0000ff>new</font> HashMap();
    <font color=#0000ff>for</font>(<font color=#0000ff>int</font> i = 0; i &lt; states.length; i++)
      transitions.put(states[i][0], states[i][1]);
  }
  <font color=#0000ff>public</font> <font color=#0000ff>abstract</font> <font color=#0000ff>void</font> run();
  <font color=#0000ff>public</font> State next(Input i) {
    <font color=#0000ff>if</font>(transitions.containsKey(i))
      <font color=#0000ff>return</font> (State)transitions.get(i);
    <font color=#0000ff>else</font>
      <font color=#0000ff>throw</font> <font color=#0000ff>new</font> RuntimeException(
        <font color=#004488>"Input not supported for current state"</font>);
  }
}

<font color=#0000ff>class</font> MouseTrap <font color=#0000ff>extends</font> StateMachine {
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> State
    waiting = <font color=#0000ff>new</font> Waiting(),
    luring = <font color=#0000ff>new</font> Luring(),
    trapping = <font color=#0000ff>new</font> Trapping(),
    holding = <font color=#0000ff>new</font> Holding();
  <font color=#0000ff>public</font> MouseTrap() {
    <font color=#0000ff>super</font>(waiting); <font color=#009900>// Initial state</font>
  }
}

<font color=#0000ff>class</font> Waiting <font color=#0000ff>extends</font> StateT {
  <font color=#0000ff>public</font> <font color=#0000ff>void</font> run() { 
    System.out.println(
      <font color=#004488>"Waiting: Broadcasting cheese smell"</font>);
  }
  <font color=#0000ff>public</font> State next(Input i) {
    <font color=#009900>// Delayed initialization:</font>
    <font color=#0000ff>if</font>(transitions == <font color=#0000ff>null</font>)
      init(<font color=#0000ff>new</font> Object[][] { 
        { MouseAction.appears, MouseTrap.luring },
      });
    <font color=#0000ff>return</font> <font color=#0000ff>super</font>.next(i);
  }
}

<font color=#0000ff>class</font> Luring <font color=#0000ff>extends</font> StateT {
  <font color=#0000ff>public</font> <font color=#0000ff>void</font> run() {
    System.out.println(
      <font color=#004488>"Luring: Presenting Cheese, door open"</font>);
  }
  <font color=#0000ff>public</font> State next(Input i) {
    <font color=#0000ff>if</font>(transitions == <font color=#0000ff>null</font>)
      init(<font color=#0000ff>new</font> Object[][] { 
        { MouseAction.enters, MouseTrap.trapping },
        { MouseAction.runsAway, MouseTrap.waiting },
      });
    <font color=#0000ff>return</font> <font color=#0000ff>super</font>.next(i);
  }
}

<font color=#0000ff>class</font> Trapping <font color=#0000ff>extends</font> StateT {
  <font color=#0000ff>public</font> <font color=#0000ff>void</font> run() {
    System.out.println(<font color=#004488>"Trapping: Closing door"</font>);
  }
  <font color=#0000ff>public</font> State next(Input i) {
    <font color=#0000ff>if</font>(transitions == <font color=#0000ff>null</font>)
      init(<font color=#0000ff>new</font> Object[][] { 
        { MouseAction.escapes, MouseTrap.waiting },
        { MouseAction.trapped, MouseTrap.holding },
      });
    <font color=#0000ff>return</font> <font color=#0000ff>super</font>.next(i);
  }
}

<font color=#0000ff>class</font> Holding <font color=#0000ff>extends</font> StateT {
  <font color=#0000ff>public</font> <font color=#0000ff>void</font> run() {
    System.out.println(<font color=#004488>"Holding: Mouse caught"</font>);
  }
  <font color=#0000ff>public</font> State next(Input i) {
    <font color=#0000ff>if</font>(transitions == <font color=#0000ff>null</font>)
      init(<font color=#0000ff>new</font> Object[][] { 
        { MouseAction.removed, MouseTrap.waiting },
      });
    <font color=#0000ff>return</font> <font color=#0000ff>super</font>.next(i);
  }
}

<font color=#0000ff>public</font> <font color=#0000ff>class</font> MouseTrap2Test <font color=#0000ff>extends</font> UnitTest {
  MouseTrap trap = <font color=#0000ff>new</font> MouseTrap();
  MouseMoveList moves = 
    <font color=#0000ff>new</font> MouseMoveList(
      <font color=#0000ff>new</font> StringList(<font color=#004488>"..</font><font color=#004488>/mouse</font><font color=#004488>/MouseMoves.txt"</font>)
        .iterator());
  <font color=#0000ff>public</font> <font color=#0000ff>void</font> test() {
    trap.runAll(moves.iterator());
  }
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> main(String args[]) {
    <font color=#0000ff>new</font> MouseTrap2Test().test();
  }
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE><DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The rest of the code is
identical &#8211; the difference is in the <B>next(&#160;)</B> methods and the
<B>StateT</B> class.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">If you have to create and maintain a lot
of <B>State</B> classes, this approach is an improvement, since it&#8217;s
easier to quickly read and understand the state transitions from looking at the
table.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><A NAME="_Toc524504104"></A><BR></P></DIV>
<A NAME="Heading30"></A><FONT FACE = "Verdana"><H2 ALIGN="LEFT">
Table-Driven State Machine<A NAME="AAA"></A></H2></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The advantage of the previous design is
that all the information about a state, including the state transition
information, is located within the state class itself. This is generally a good
design principle.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">However, in a pure state machine, the
machine can be completely represented by a single state-transition table. This
has the advantage of locating all the information about the state machine in a
single place, which means that you can more easily create and maintain the table
based on a classic state-transition diagram.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The classic state-transition diagram uses
a circle to represent each state, and lines from the state pointing to all
states that state can transition into. Each transition line is annotated with
conditions for transition and an action during transition. Here&#8217;s what it
looks like:</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">(Simple State Machine
Diagram)</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Goals:</FONT><BR></P></DIV>
<UL>
<LI><FONT FACE="Georgia">translation of state
diagram</FONT><LI><FONT FACE="Symbol">	</FONT><FONT FACE="Georgia">Vector of
change: the state diagram
representation</FONT><LI><FONT FACE="Georgia">implementation</FONT><LI><FONT FACE="Georgia">excess
of states (you could represent every single change with a new
state)</FONT><LI><FONT FACE="Georgia">and
flexibility</FONT></UL><DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Observations:</FONT><BR></P></DIV>
<UL>
<LI><FONT FACE="Symbol">	</FONT><FONT FACE="Georgia">States are trivial &#8211;
no information or functions/data, just an
identity</FONT><LI><FONT FACE="Georgia">like the State
pattern!</FONT><LI><FONT FACE="Georgia">machine governs the move from state to
state</FONT><LI><FONT FACE="Georgia">to
flyweight</FONT><LI><FONT FACE="Georgia">state may move to many
others</FONT><LI><FONT FACE="Georgia">&amp; action functions must also be
external to states</FONT><LI><FONT FACE="Georgia">description in a single table
containing all variations, for ease of
configuration</FONT></UL><DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Example:</FONT><BR></P></DIV>
<UL>
<LI><FONT FACE="Georgia">Machine &amp; Table-Driven
Code</FONT><LI><FONT FACE="Georgia">a vending
machine</FONT><LI><FONT FACE="Georgia">several other
patterns</FONT><LI><FONT FACE="Georgia">common state-machine code from specific
application (like template method)</FONT><LI><FONT FACE="Georgia">input causes a
seek for appropriate solution (like chain of
responsibility)</FONT><LI><FONT FACE="Georgia">and transitions are encapsulated
in function objects (objects that hold
functions)</FONT><LI><FONT FACE="Symbol">	</FONT><FONT FACE="Georgia">Java
constraint: methods are not first-class
objects</FONT></UL><DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><IMG SRC="TIPatt01.gif"></FONT><A NAME="_Toc524504105"></A><BR></P></DIV>
<A NAME="Heading31"></A><FONT FACE = "Verdana"><H3 ALIGN="LEFT">
The State class</H3></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The <B>State</B> class is distinctly
different from before, since it is really just a placeholder with a name. Thus
it is not inherited from previous <B>State</B> classes:</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: c04:statemachine2:State.java</font>
<font color=#0000ff>package</font> c04.statemachine2;
<font color=#0000ff>public</font> <font color=#0000ff>class</font> State {
  <font color=#0000ff>private</font> String name;
  <font color=#0000ff>public</font> State(String nm) { name = nm; }
  <font color=#0000ff>public</font> String toString() { <font color=#0000ff>return</font> name; }
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE><DIV ALIGN="LEFT"><P><A NAME="_Toc524504106"></A><BR></P></DIV>
<A NAME="Heading32"></A><FONT FACE = "Verdana"><H3 ALIGN="LEFT">
Conditions for transition</H3></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">In the state transition diagram, an input
is tested to see if it meets the condition necessary to transfer to the state
under question. As before, the <B>Input</B> is just a tagging
interface:</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: c04:statemachine2:Input.java</font>
<font color=#009900>// Inputs to a state machine</font>
<font color=#0000ff>package</font> c04.statemachine2;

<font color=#0000ff>public</font> <font color=#0000ff>interface</font> Input {} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE><DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The
<B>Condition</B> evaluates the <B>Input</B> to decide whether this row in the
table is the correct transition:</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: c04:statemachine2:Condition.java</font>
<font color=#009900>// Condition function object for state machine</font>
<font color=#0000ff>package</font> c04.statemachine2;

<font color=#0000ff>public</font> <font color=#0000ff>interface</font> Condition {
  <font color=#0000ff>boolean</font> condition(Input i);
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE><DIV ALIGN="LEFT"><P><A NAME="_Toc524504107"></A><BR></P></DIV>
<A NAME="Heading33"></A><FONT FACE = "Verdana"><H3 ALIGN="LEFT">
Transition actions</H3></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">If the <B>Condition</B> returns
<B>true</B>, then the transition to a new state is made, and as that transition
is made some kind of action occurs (in the previous state machine design, this
was the <B>run(&#160;)</B> method):</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: c04:statemachine2:Transition.java</font>
<font color=#009900>// Transition function object for state machine</font>
<font color=#0000ff>package</font> c04.statemachine2;

<font color=#0000ff>public</font> <font color=#0000ff>interface</font> Transition {
  <font color=#0000ff>void</font> transition(Input i);
} <font color=#009900>///:~<A NAME="_Toc524504108"></A></font></PRE></FONT></BLOCKQUOTE><A NAME="Heading34"></A><FONT FACE = "Verdana"><H3 ALIGN="LEFT">
The table</H3></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">With these classes in place, we can set
up a 3-dimensional table where </FONT><FONT FACE="Georgia">each row completely
describes a state. The first element in the row is the current state, and the
rest of the elements are each a row indicating what the <I>type </I>of the input
can be, the condition that must be satisfied in order for this state change to
be the correct one, the action that happens during transition, and the new state
to move into. Note that the <B>Input</B> object is not just used for its type,
it is also a <I>Messenger</I> object that carries information to the
<B>Condition</B> and <B>Transition</B> objects:</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE>{ {CurrentState},
  {Input, Condition(Input), Transition(Input), Next},
  {Input, Condition(Input), Transition(Input), Next},
  {Input, Condition(Input), Transition(Input), Next},
   ...
}</PRE></FONT></BLOCKQUOTE>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE></PRE></FONT></BLOCKQUOTE><DIV ALIGN="LEFT"><P><A NAME="_Toc524504109"></A><BR></P></DIV>
<A NAME="Heading35"></A><FONT FACE = "Verdana"><H3 ALIGN="LEFT">
The basic machine</H3></FONT>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: c04:statemachine2:StateMachine.java</font>
<font color=#009900>// A table-driven state machine</font>
<font color=#0000ff>package</font> c04.statemachine2;
<font color=#0000ff>import</font> java.util.*;

<font color=#0000ff>public</font> <font color=#0000ff>class</font> StateMachine {
  <font color=#0000ff>private</font> State state;
  <font color=#0000ff>private</font> Map map = <font color=#0000ff>new</font> HashMap();
  <font color=#0000ff>public</font> StateMachine(State initial) {
    state = initial;
  }
  <font color=#0000ff>public</font> <font color=#0000ff>void</font> buildTable(Object[][][] table) {
    <font color=#0000ff>for</font>(<font color=#0000ff>int</font> i = 0; i &lt; table.length; i++) {
      Object[][] row = table[i];
      Object currentState = row[0][0];
      List transitions = <font color=#0000ff>new</font> ArrayList();
      <font color=#0000ff>for</font>(<font color=#0000ff>int</font> j = 1; j &lt; row.length; j++)
        transitions.add(row[j]);
      map.put(currentState, transitions);
    }
  }
  <font color=#0000ff>public</font> <font color=#0000ff>void</font> nextState(Input input) {
    Iterator it=((List)map.get(state)).iterator();
    <font color=#0000ff>while</font>(it.hasNext()) {
      Object[] tran = (Object[])it.next();
      <font color=#0000ff>if</font>(input == tran[0] || 
         input.getClass() == tran[0]) {
        <font color=#0000ff>if</font>(tran[1] != <font color=#0000ff>null</font>) {
          Condition c = (Condition)tran[1];
          <font color=#0000ff>if</font>(!c.condition(input))
            <font color=#0000ff>continue</font>; <font color=#009900>// Failed test</font>
        }
        <font color=#0000ff>if</font>(tran[2] != <font color=#0000ff>null</font>)
          ((Transition)tran[2]).transition(input);
        state = (State)tran[3];
        <font color=#0000ff>return</font>;
      }
    }
    <font color=#0000ff>throw</font> <font color=#0000ff>new</font> RuntimeException(
      <font color=#004488>"Input not supported for current state"</font>);
  }
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE><DIV ALIGN="LEFT"><P><A NAME="_Toc524504110"></A><BR></P></DIV>
<A NAME="Heading36"></A><FONT FACE = "Verdana"><H3 ALIGN="LEFT">
Simple vending machine</H3></FONT>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: c04:vendingmachine:VendingMachine.java</font>
<font color=#009900>// Demonstrates use of StateMachine.java</font>
<font color=#0000ff>package</font> c04.vendingmachine;
<font color=#0000ff>import</font> c04.statemachine2.*;

<font color=#0000ff>final</font> <font color=#0000ff>class</font> VM <font color=#0000ff>extends</font> State {
  <font color=#0000ff>private</font> VM(String nm) { <font color=#0000ff>super</font>(nm); }
  <font color=#0000ff>public</font> <font color=#0000ff>final</font> <font color=#0000ff>static</font> VM
    quiescent = <font color=#0000ff>new</font> VM(<font color=#004488>"Quiesecent"</font>),
    collecting = <font color=#0000ff>new</font> VM(<font color=#004488>"Collecting"</font>),
    selecting = <font color=#0000ff>new</font> VM(<font color=#004488>"Selecting"</font>),
    unavailable = <font color=#0000ff>new</font> VM(<font color=#004488>"Unavailable"</font>),
    wantMore = <font color=#0000ff>new</font> VM(<font color=#004488>"Want More?"</font>),
    noChange = <font color=#0000ff>new</font> VM(<font color=#004488>"Use Exact Change Only"</font>),
    makesChange = <font color=#0000ff>new</font> VM(<font color=#004488>"Machine makes change"</font>);
}
<font color=#0000ff>final</font> <font color=#0000ff>class</font> HasChange <font color=#0000ff>implements</font> Input {
  <font color=#0000ff>private</font> String name;
  <font color=#0000ff>private</font> HasChange(String nm) { name = nm; }
  <font color=#0000ff>public</font> String toString() { <font color=#0000ff>return</font> name; }
  <font color=#0000ff>public</font> <font color=#0000ff>final</font> <font color=#0000ff>static</font> HasChange
    yes = <font color=#0000ff>new</font> HasChange(<font color=#004488>"Has change"</font>),
    no = <font color=#0000ff>new</font> HasChange(<font color=#004488>"Cannot make change"</font>);
}
<font color=#0000ff>class</font> ChangeAvailable <font color=#0000ff>extends</font> StateMachine {
  <font color=#0000ff>public</font> ChangeAvailable() {
    <font color=#0000ff>super</font>(VM.makesChange);
    buildTable(<font color=#0000ff>new</font> Object[][][]{
      { {VM.makesChange}, <font color=#009900>// Current state</font>
        <font color=#009900>// Input, test, transition, next state:</font>
        {HasChange.no, <font color=#0000ff>null</font>, <font color=#0000ff>null</font>, VM.noChange}},
      { {VM.noChange}, <font color=#009900>// Current state</font>
        <font color=#009900>// Input, test, transition, next state:</font>
        {HasChange.yes, <font color=#0000ff>null</font>, 
         <font color=#0000ff>null</font>, VM.makesChange}},
    });
  }
}
<font color=#0000ff>final</font> <font color=#0000ff>class</font> Money <font color=#0000ff>implements</font> Input {
  <font color=#0000ff>private</font> String name;
  <font color=#0000ff>private</font> <font color=#0000ff>int</font> value;
  <font color=#0000ff>private</font> Money(String nm, <font color=#0000ff>int</font> val) {
    name = nm;
    value = val;
  }
  <font color=#0000ff>public</font> String toString() { <font color=#0000ff>return</font> name; }
  <font color=#0000ff>public</font> <font color=#0000ff>int</font> getValue() { <font color=#0000ff>return</font> value; }
  <font color=#0000ff>public</font> <font color=#0000ff>final</font> <font color=#0000ff>static</font> Money
    quarter = <font color=#0000ff>new</font> Money(<font color=#004488>"Quarter"</font>, 25),
    dollar = <font color=#0000ff>new</font> Money(<font color=#004488>"Dollar"</font>, 100);
}
<font color=#0000ff>final</font> <font color=#0000ff>class</font> Quit <font color=#0000ff>implements</font> Input {
  <font color=#0000ff>private</font> Quit() {}
  <font color=#0000ff>public</font> String toString() { <font color=#0000ff>return</font> <font color=#004488>"Quit"</font>; }
  <font color=#0000ff>public</font> <font color=#0000ff>final</font> <font color=#0000ff>static</font> Quit quit = <font color=#0000ff>new</font> Quit();
}
<font color=#0000ff>final</font> <font color=#0000ff>class</font> FirstDigit <font color=#0000ff>implements</font> Input {
  <font color=#0000ff>private</font> String name;
  <font color=#0000ff>private</font> <font color=#0000ff>int</font> value;
  <font color=#0000ff>private</font> FirstDigit(String nm, <font color=#0000ff>int</font> val) {
    name = nm;
    value = val;
  }
  <font color=#0000ff>public</font> String toString() { <font color=#0000ff>return</font> name; }
  <font color=#0000ff>public</font> <font color=#0000ff>int</font> getValue() { <font color=#0000ff>return</font> value; }
  <font color=#0000ff>public</font> <font color=#0000ff>final</font> <font color=#0000ff>static</font> FirstDigit
    A = <font color=#0000ff>new</font> FirstDigit(<font color=#004488>"A"</font>, 0),
    B = <font color=#0000ff>new</font> FirstDigit(<font color=#004488>"B"</font>, 1),
    C = <font color=#0000ff>new</font> FirstDigit(<font color=#004488>"C"</font>, 2),
    D = <font color=#0000ff>new</font> FirstDigit(<font color=#004488>"D"</font>, 3);
}
<font color=#0000ff>final</font> <font color=#0000ff>class</font> SecondDigit <font color=#0000ff>implements</font> Input {
  <font color=#0000ff>private</font> String name;
  <font color=#0000ff>private</font> <font color=#0000ff>int</font> value;
  <font color=#0000ff>private</font> SecondDigit(String nm, <font color=#0000ff>int</font> val) {
    name = nm;
    value = val;
  }
  <font color=#0000ff>public</font> String toString() { <font color=#0000ff>return</font> name; }
  <font color=#0000ff>public</font> <font color=#0000ff>int</font> getValue() { <font color=#0000ff>return</font> value; }
  <font color=#0000ff>public</font> <font color=#0000ff>final</font> <font color=#0000ff>static</font> SecondDigit
    one = <font color=#0000ff>new</font> SecondDigit(<font color=#004488>"one"</font>, 0),
    two = <font color=#0000ff>new</font> SecondDigit(<font color=#004488>"two"</font>, 1),
    three = <font color=#0000ff>new</font> SecondDigit(<font color=#004488>"three"</font>, 2),
    four = <font color=#0000ff>new</font> SecondDigit(<font color=#004488>"four"</font>, 3);
}
<font color=#0000ff>class</font> ItemSlot {
  <font color=#0000ff>int</font> price;
  <font color=#0000ff>int</font> quantity;
  <font color=#0000ff>static</font> <font color=#0000ff>int</font> counter = 0;
  String id = Integer.toString(counter++);
  <font color=#0000ff>public</font> ItemSlot(<font color=#0000ff>int</font> prc, <font color=#0000ff>int</font> quant) {
    price = prc;
    quantity = quant;
  }
  <font color=#0000ff>public</font> String toString() { <font color=#0000ff>return</font> id; }
  <font color=#0000ff>public</font> <font color=#0000ff>int</font> getPrice() { <font color=#0000ff>return</font> price; }
  <font color=#0000ff>public</font> <font color=#0000ff>int</font> getQuantity() { <font color=#0000ff>return</font> quantity; }
  <font color=#0000ff>public</font> <font color=#0000ff>void</font> decrQuantity() { quantity--; }
}
<font color=#0000ff>public</font> <font color=#0000ff>class</font> VendingMachine <font color=#0000ff>extends</font> StateMachine{
  StateMachine changeAvailable = 
    <font color=#0000ff>new</font> ChangeAvailable();
  <font color=#0000ff>int</font> amount = 0;
  FirstDigit first = <font color=#0000ff>null</font>;
  ItemSlot[][] items = <font color=#0000ff>new</font> ItemSlot[4][4];
  Condition notEnough = <font color=#0000ff>new</font> Condition() {
    <font color=#0000ff>public</font> <font color=#0000ff>boolean</font> condition(Input input) {
      <font color=#0000ff>int</font> i1 = first.getValue();
      <font color=#0000ff>int</font> i2 = ((SecondDigit)input).getValue();
      <font color=#0000ff>return</font> items[i1][i2].getPrice() &gt; amount;
    }
  };
  Condition itemAvailable = <font color=#0000ff>new</font> Condition() {
    <font color=#0000ff>public</font> <font color=#0000ff>boolean</font> condition(Input input) {
      <font color=#0000ff>int</font> i1 = first.getValue();
      <font color=#0000ff>int</font> i2 = ((SecondDigit)input).getValue();
      <font color=#0000ff>return</font> items[i1][i2].getQuantity() &gt; 0;
    }
  };
  Condition itemNotAvailable = <font color=#0000ff>new</font> Condition() {
    <font color=#0000ff>public</font> <font color=#0000ff>boolean</font> condition(Input input) {
      <font color=#0000ff>return</font> !itemAvailable.condition(input);
      <font color=#009900>//int i1 = first.getValue();</font>
      <font color=#009900>//int i2 = ((SecondDigit)input).getValue();</font>
      <font color=#009900>//return items[i1][i2].getQuantity() == 0;</font>
    }
  };
  Transition clearSelection = <font color=#0000ff>new</font> Transition() {
    <font color=#0000ff>public</font> <font color=#0000ff>void</font> transition(Input input) {
      <font color=#0000ff>int</font> i1 = first.getValue();
      <font color=#0000ff>int</font> i2 = ((SecondDigit)input).getValue();
      ItemSlot is = items[i1][i2];
      System.out.println(
        <font color=#004488>"Clearing selection: item "</font> + is +
        <font color=#004488>" costs "</font> + is.getPrice() +
        <font color=#004488>" and has quantity "</font> + is.getQuantity());
      first = <font color=#0000ff>null</font>;
    }
  };
  Transition dispense = <font color=#0000ff>new</font> Transition() {
    <font color=#0000ff>public</font> <font color=#0000ff>void</font> transition(Input input) {
      <font color=#0000ff>int</font> i1 = first.getValue();
      <font color=#0000ff>int</font> i2 = ((SecondDigit)input).getValue();
      ItemSlot is = items[i1][i2];
      System.out.println(<font color=#004488>"Dispensing item "</font> + 
        is + <font color=#004488>" costs "</font> + is.getPrice() +
        <font color=#004488>" and has quantity "</font> + is.getQuantity());
      items[i1][i2].decrQuantity();
      System.out.println(<font color=#004488>"New Quantity "</font> + 
        is.getQuantity());
      amount -= is.getPrice();
      System.out.println(<font color=#004488>"Amount remaining "</font> + 
        amount);
    }
  };
  Transition showTotal = <font color=#0000ff>new</font> Transition() {
    <font color=#0000ff>public</font> <font color=#0000ff>void</font> transition(Input input) {
      amount += ((Money)input).getValue();
      System.out.println(<font color=#004488>"Total amount = "</font> + 
        amount);
    }
  };
  Transition returnChange = <font color=#0000ff>new</font> Transition() {
    <font color=#0000ff>public</font> <font color=#0000ff>void</font> transition(Input input) {
      System.out.println(<font color=#004488>"Returning "</font> + amount);
      amount = 0;
    }
  };
  Transition showDigit = <font color=#0000ff>new</font> Transition() {
    <font color=#0000ff>public</font> <font color=#0000ff>void</font> transition(Input input) {
      first = (FirstDigit)input;
      System.out.println(<font color=#004488>"First Digit= "</font>+ first);
    }
  };
  <font color=#0000ff>public</font> VendingMachine() {
    <font color=#0000ff>super</font>(VM.quiescent); <font color=#009900>// Initial state</font>
    <font color=#0000ff>for</font>(<font color=#0000ff>int</font> i = 0; i &lt; items.length; i++)
      <font color=#0000ff>for</font>(<font color=#0000ff>int</font> j = 0; j &lt; items[i].length; j++)
        items[i][j] = <font color=#0000ff>new</font> ItemSlot((j+1)*25, 5);
    items[3][0] = <font color=#0000ff>new</font> ItemSlot(25, 0);
    buildTable(<font color=#0000ff>new</font> Object[][][]{
      { {VM.quiescent}, <font color=#009900>// Current state</font>
        <font color=#009900>// Input, test, transition, next state:</font>
        {Money.<font color=#0000ff>class</font>, <font color=#0000ff>null</font>, 
         showTotal, VM.collecting}},
      { {VM.collecting}, <font color=#009900>// Current state</font>
        <font color=#009900>// Input, test, transition, next state:</font>
        {Quit.quit, <font color=#0000ff>null</font>, 
         returnChange, VM.quiescent},
        {Money.<font color=#0000ff>class</font>, <font color=#0000ff>null</font>, 
         showTotal, VM.collecting},
        {FirstDigit.<font color=#0000ff>class</font>, <font color=#0000ff>null</font>, 
         showDigit, VM.selecting}},
      { {VM.selecting}, <font color=#009900>// Current state</font>
        <font color=#009900>// Input, test, transition, next state:</font>
        {Quit.quit, <font color=#0000ff>null</font>, 
         returnChange, VM.quiescent},
        {SecondDigit.<font color=#0000ff>class</font>, notEnough, 
         clearSelection, VM.collecting},
        {SecondDigit.<font color=#0000ff>class</font>, itemNotAvailable, 
         clearSelection, VM.unavailable},
        {SecondDigit.<font color=#0000ff>class</font>, itemAvailable, 
         dispense, VM.wantMore}},
      { {VM.unavailable}, <font color=#009900>// Current state</font>
        <font color=#009900>// Input, test, transition, next state:</font>
        {Quit.quit, <font color=#0000ff>null</font>, 
         returnChange, VM.quiescent},
        {FirstDigit.<font color=#0000ff>class</font>, <font color=#0000ff>null</font>, 
         showDigit, VM.selecting}},
      { {VM.wantMore}, <font color=#009900>// Current state</font>
        <font color=#009900>// Input, test, transition, next state:</font>
        {Quit.quit, <font color=#0000ff>null</font>, 
         returnChange, VM.quiescent},
        {FirstDigit.<font color=#0000ff>class</font>, <font color=#0000ff>null</font>, 
         showDigit, VM.selecting}},
    });
  }
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE><DIV ALIGN="LEFT"><P><A NAME="_Toc524504111"></A><BR></P></DIV>
<A NAME="Heading37"></A><FONT FACE = "Verdana"><H3 ALIGN="LEFT">
Testing the machine</H3></FONT>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: c04:vendingmachine:VendingMachineTest.java</font>
<font color=#009900>// Demonstrates use of StateMachine.java</font>
<font color=#0000ff>package</font> c04.vendingmachine;
<font color=#0000ff>import</font> c04.statemachine2.*;
<font color=#0000ff>import</font> com.bruceeckel.test.*;

<font color=#0000ff>public</font> <font color=#0000ff>class</font> VendingMachineTest <font color=#0000ff>extends</font> UnitTest{
  VendingMachine vm = <font color=#0000ff>new</font> VendingMachine();
  Input[] inputs = {
    Money.quarter,
    Money.quarter,
    Money.dollar,
    FirstDigit.A,
    SecondDigit.two,
    FirstDigit.A,
    SecondDigit.two,
    FirstDigit.C,
    SecondDigit.three,
    FirstDigit.D,
    SecondDigit.one,
    Quit.quit,
  };
  <font color=#0000ff>public</font> <font color=#0000ff>void</font> test() {
    <font color=#0000ff>for</font>(<font color=#0000ff>int</font> i = 0; i &lt; inputs.length; i++)
      vm.nextState(inputs[i]);
  }
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> main(String[] args) {
    <font color=#0000ff>new</font> VendingMachineTest().test();
  }
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE><DIV ALIGN="LEFT"><P><A NAME="_Toc524504112"></A><BR></P></DIV>
<A NAME="Heading38"></A><FONT FACE = "Verdana"><H2 ALIGN="LEFT">
Tools</H2></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Another approach, as your state machine
gets bigger, is to use an automation tool whereby you configure a table and let
the tool generate the state machine code for you. This can be created yourself
using a language like Python, but there are also free, open-source tools such as
<I>Libero</I>, at <A HREF="http://www.imatix.com">http://www.imatix.com</A>.
</FONT><A NAME="_Toc524504113"></A><BR></P></DIV>
<A NAME="Heading39"></A><FONT FACE = "Verdana"><H2 ALIGN="LEFT">
Exercises</H2></FONT>
<OL>
<LI><FONT FACE="Verdana">	</FONT><FONT FACE="Georgia">Create an example of the
&#8220;virtual
proxy.&#8221;</FONT><LI><FONT FACE="Verdana">	</FONT><FONT FACE="Georgia">Create
an example of the &#8220;Smart reference&#8221; proxy where you keep count of
the number of method calls to a particular
object.</FONT><LI><FONT FACE="Verdana">	</FONT><FONT FACE="Georgia">Create a
program similar to certain DBMS systems that only allow a certain number of
connections at any time. To implement this, use a singleton-like system that
controls the number of &#8220;connection&#8221; objects that it creates. When a
user is finished with a connection, the system must be informed so that it can
check that connection back in to be reused. To guarantee this, provide a proxy
object instead of a reference to the actual connection, and design the proxy so
that it will cause the connection to be released back to the
system.</FONT><LI><FONT FACE="Verdana">	</FONT><FONT FACE="Georgia">Using the
<I>State</I>,<I> </I>make a class called <B>UnpredictablePerson</B> which
changes the kind of response to its <B>hello(&#160;)</B> method depending on
what kind of <B>Mood</B> it&#8217;s in. Add an additional kind of <B>Mood</B>
called
<B>Prozac</B>.</FONT><LI><FONT FACE="Verdana">	</FONT><FONT FACE="Georgia">Create
a simple copy-on write
implementation.</FONT><LI><FONT FACE="Verdana">	</FONT><FONT FACE="Georgia">Apply
<B>TransitionTable.java</B> to the &#8220;Washer&#8221;
problem.</FONT><LI><FONT FACE="Verdana">	</FONT><FONT FACE="Georgia">Create a
<I>StateMachine</I> system whereby the current state along with input
information determines the next state that the system will be in. To do this,
each state must store a reference back to the proxy object (the state
controller) so that it can request the state change. Use a <B>HashMap</B> to
create a table of states, where the key is a <B>String</B> naming the new state
and the value is the new state object. Inside each state subclass override a
method <B>nextState(&#160;)</B> that has its own state-transition table. The
input to <B>nextState(&#160;)</B> should be a single word that comes from a text
file containing one word per
line.</FONT><LI><FONT FACE="Verdana">	</FONT><FONT FACE="Georgia">Modify the
previous exercise so that the state machine can be configured by
creating/modifying a single multi-dimensional
array.</FONT><LI><FONT FACE="Verdana">	</FONT><FONT FACE="Georgia">Modify the
&#8220;mood&#8221; exercise from the previous session so that it becomes a state
machine using
StateMachine.java</FONT><LI><FONT FACE="Verdana">	</FONT><FONT FACE="Georgia">Create
an elevator state machine system using
StateMachine.java</FONT><LI><FONT FACE="Verdana">	</FONT><FONT FACE="Georgia">Create
a heating/air-conditioning system using
StateMachine.java</FONT><LI><FONT FACE="Verdana">	</FONT><FONT FACE="Georgia">A
<I>generator</I> is an object that produces other objects, just like a factory,
except that the generator function doesn&#8217;t require any arguments. Create a
<B>MouseMoveGenerator</B> which produces correct <B>MouseMove</B> actions as
outputs each time the generator function is called (that is, the mouse must move
in the proper sequence, thus the possible moves are based on the previous move
&#8211; it&#8217;s another state machine). Add a method <B>iterator( ) </B>to
produce an iterator, but this method should take an <B>int</B> argument that
specifies the number of moves to produce before <B>hasNext( )</B> returns
<B>false</B>.</FONT></OL>
<HR><DIV ALIGN="LEFT"><P><A NAME="fn9" HREF="#fnB9">[9]</A><FONT FACE="Georgia"> No
mice were harmed in the creation of this example.</FONT><BR></P></DIV>

<DIV ALIGN="CENTER">
    <FONT FACE="Verdana" size = "-1">
     [ <a href="Chapter03.html">Previous Chapter</a> ] 
    [ <a href="SimpleContents.html">Short TOC</a> ] 
    [ <a href="Contents.html">Table of Contents</a> ] 
    [ <a href="DocIndex.html">Index</a> ]
     [ <a href="Chapter0X.html">Next Chapter</a> ] 
    </FONT>
    <BR>
 Last Update:09/08/2001</P></DIV>

</BODY>

</HTML>
